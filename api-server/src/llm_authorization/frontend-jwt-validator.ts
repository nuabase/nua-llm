// To validate JWT that comes directly from an end-user browser. This is a shortlived
// token generated by the client's backend server, and passed to the nuabase TS sdk
// which runs on the front-end. This token approach is what allows Nuabase to be called
// directly from the browser. Note that this will contain an `iss` which would be the
// user_id in our system (aka the actual Nuabase user), and a `sub` which would be their
// end-user. We keep that id for budgeting, abuse prevention, rate limits etc.

import { decryptRailsMessageEncryptor } from "#lib/activesupport-message-encryptor";
import { config } from "#lib/config";
import { getErrorMessageFromException } from "#lib/error-utils";
import { NuaValidationError } from "nua-llm-core";
import {
  decodeJwt,
  decodeProtectedHeader,
  errors,
  JWTPayload,
  jwtVerify,
} from "jose";
import { createSecretKey } from "crypto";
import { SigningKey, SigningKeysModel } from "../models/signing-keys-model";

// JWTPayload treats all these values as optional, but for us they are all mandatory.
type FrontendJwtPayload = {
  iss: string;
  sub: string;
  kid: string;
  jti: string;
  exp: number;
  iat: number;
  aud: string | string[];
};

const signingKeysModel = new SigningKeysModel();

export type FrontendJwtDecodeResult = { jwtExpired: boolean | undefined } & (
  | {
    userId: string;
    endConsumerId: string | null;
  }
  | NuaValidationError
);

export async function decodeFrontendJWT(
  rawToken: string,
): Promise<FrontendJwtDecodeResult> {
  // uv = unvalidated
  let uvPayload: JWTPayload | undefined

  try {
    uvPayload = decodeJwt(rawToken);
  } catch (e) {
    if (e instanceof errors.JOSEError) {
      return {
        kind: "validation-error",
        message: "Invalid API key/JWT token",
        jwtExpired: undefined,
      };
    }

    throw e;
  }
  const uvProtectedHeader = decodeProtectedHeader(rawToken);

  const exp = uvPayload.exp;
  if (typeof exp !== "number" || !Number.isFinite(exp)) {
    return {
      kind: "validation-error",
      // at this point, since the token is invalid, we don't know for sure if the user
      // intended a jwt token or an API key. for example, if they were copy-pasting directly from the docs, the value would be
      // YOUR_NUABASE_API_KEY, until they change it. So we'll return a general message
      message: "Invalid API key/JWT token",
      jwtExpired: undefined,
    };
  }

  if (exp <= Math.floor(Date.now() / 1000)) {
    return {
      kind: "validation-error",
      message: "JWT token has expired",
      jwtExpired: true,
    };
  }

  if (
    typeof uvProtectedHeader.alg === "string" &&
    uvProtectedHeader.alg === "HS256"
  ) {
    // The `iss` (issuer) is going to be our actual user. The `sub` will be their end-user who's using the browser.
    // This is all defined in the token minting stage, in our back-end SDK. For now, in Jalories,
    // jwt_token_generator.rb.

    if (
      typeof uvPayload.kid === "string" &&
      typeof uvPayload.iss === "string"
    ) {
      const userId = uvPayload.iss;
      const kid = uvPayload.kid;

      const signingKey = await signingKeysModel.findByUserIdAndKid(userId, kid);
      if (signingKey) {
        const tokenEncryptionKey = decryptTokenKey(signingKey);

        if (tokenEncryptionKey) {
          // The token encryption key is encoded and saved by console signing_key_service.rb as base64url. However, here,
          // that decoding is done by createSecretKey. We just have to give it a string array (regular string won't work)
          const secretKey = createSecretKey(
            Buffer.from(tokenEncryptionKey, "utf8"),
          );

          try {
            const { payload, protectedHeader } = await jwtVerify(
              rawToken,
              secretKey,
              { algorithms: ["HS256"] },
            );

            // FULLY VERIFIED AND VALIDATED AT THIS POINT
            signingKeysModel.recordUse(kid);
            return {
              userId: signingKey.user_id,
              endConsumerId: payload.sub ?? null,
              jwtExpired: false,
            };
          } catch (err) {
            return {
              kind: "validation-error",
              message: getErrorMessageFromException(err),
              jwtExpired: undefined,
            };
          }
        }
      }
    }
  }

  return {
    kind: "validation-error",
    message: "Invalid API key/JWT token",
    jwtExpired: undefined,
  };
}

function decryptTokenKey(s: SigningKey): string | null {
  const encryptedSecret = s.secret_ciphertext;
  if (encryptedSecret) {
    const tokenEncryptionKey = decryptRailsMessageEncryptor(
      encryptedSecret,
      config.encryptionKeyDbStorageSigningKey,
    );
    return tokenEncryptionKey;
  }
  return null;
}
